# A2FOMU Makefile (c) 2020 Doug Eaton

# Build environment
BUILD      := .obj
PACKAGE    := a2fomu
PROJECT    := a2runtime
CPU        := __vexriscv__
TINYUSB    := ../tinyusb

# Software can be built for a specific hardware configuration. The releases
# directory in the project root contains a sub-folder for each official version
# and may contain unofficial versions as well. The include directory of the
# particular version should contain the generated output as well as the litex
# version specific hardware folder.
ifdef RELEASE
RELEASES   := $(subst ../../release/,,$(wildcard ../../release/*))
ifeq ($(filter $(RELEASE), $(RELEASES)),)
    $(error Invalid release specified)
endif
endif

# Simulating the runtime with Verilator or iverilog is sped up by loading the
# executable directly into the very large ROM that is also simulated. This
# means the executable loads into address 0 when simulating.
# When not simulating, assume a boot-loader in ROM is copying the image from
# Flash into RAM using only local variables. It is not safe to let Foboot load
# this image directly as its interrupt handler updates global variables and
# will corrupt the image.
ifeq ($(SIM), 1)
    $(info Simulation build)
else
    LOAD_RAM_ADDR := 0x10000000
endif

# Compiler flags used for both compilation and linking
CFLAGS += \
  -march=rv32i \
  -mabi=ilp32 \
  -nostdlib \
  -DCFG_TUSB_MCU=OPT_MCU_VALENTYUSB_EPTRI \
  -D$(CPU) \
  -fno-common \
  -fomit-frame-pointer \
  -std=gnu11 \
  -flto \
  -fno-inline \
  -ggdb3 \
  -DDEBUG=0

SRC_S   := crt0-rgbraw.o
ASFLAGS += $(CFLAGS)

# Cross Compiler for RISC-V
CROSS_COMPILE ?= riscv64-unknown-elf-
CC = $(CROSS_COMPILE)gcc
CXX = $(CROSS_COMPILE)g++
OBJCOPY = $(CROSS_COMPILE)objcopy
SIZE = $(CROSS_COMPILE)size
MKDIR = mkdir
SED = sed
CP = cp
RM = rm

#-------------- Source files and compiler flags --------------

# Compiler Flags
# The following is needed if dirent_fat has filename[8],ext[3] rather than [11]
# https://gcc.gnu.org/bugs/#known: Loops do not terminate
#	-fno-aggressive-loop-optimizations
	# TODO
CFLAGS += \
	-fdata-sections \
	-ffunction-sections \
	-fsingle-precision-constant \
	-fno-strict-aliasing \
	-Wdouble-promotion \
	-Wstrict-prototypes \
	-Wall \
	-Werror \
	-Wextra \
	-Wfatal-errors \
	-Werror-implicit-function-declaration \
	-Wfloat-equal \
	-Wundef \
	-Wshadow \
	-Wwrite-strings \
	-Wsign-compare \
	-Wmissing-format-attribute \
	-Wunreachable-code \
	-Wcast-align

# Debugging/Optimization
ifeq ($(DEBUG), 1)
  CFLAGS += -Og -ggdb
else
  CFLAGS += -Os
endif
ifeq ($(LIST), 1)
  CFLAGS += -Wa,-alh,-L
endif

LD_DIR     := ../lib
LDSCRIPT   := $(LD_DIR)/linker.ld
ifdef LOAD_RAM_ADDR
LDFORMAT  := $(LD_DIR)/regions_ram.ld
LDREGIONS  := $(LD_DIR)/regions_ram.ld
CFLAGS     += -DLOAD_RAM_ADDR=$(LOAD_RAM_ADDR)
ADD_LFLAGS += -Wl,--defsym=LOAD_RAM_ADDR=$(LOAD_RAM_ADDR)
else
ifeq ($(SIM), 1)
LDREGIONS  := $(LD_DIR)/regions_sim.ld
CFLAGS     += -DSIMULATION
else
LDREGIONS  := $(LD_DIR)/regions.ld
endif
endif
LDSCRIPTS  := $(LDSCRIPT) $(LDREGIONS) $(LD_DIR)/output_format.ld
ifdef LOAD_BOOT_CONFIG
CFLAGS     += -DLOAD_BOOT_CONFIG=$(LOAD_BOOT_CONFIG)
endif

# The following must be defined when compiling TinyUSB source files.
TOP         = ../tinyusb
VENDOR      = valentyusb
CHIP_FAMILY = eptri

INC         := ../include
LDINC_DIR   := ../../hw/build/software/include/generated/

# Use the header files generated by a particular version eg: make RELEASE=1.0
ifdef RELEASE
RELEASE_DIR := ../../release/$(RELEASE)/
INC	    := $(RELEASE_DIR)/include/ ../include
LDINC_DIR   := $(RELEASE_DIR)/include/generated/
endif
#                    ADD_LFLAGS += -Wl,--defsym=LDINC_DIR=$(LDINC_DIR)

INC         += ../../hw/build/software/include/
INC         += ../../hw/deps/litex/litex/soc/software/include/
INC         += ../../hw/deps/litex/litex/soc/cores/cpu/vexriscv
INC         += $(TINYUSB)/src $(TINYUSB)/hw
INC         += $(TINYUSB)/src/portable/$(VENDOR)/$(CHIP_FAMILY)

CFLAGS += $(addprefix -I,$(INC))

LFLAGS := $(CFLAGS) $(ADD_LFLAGS) -L$(LD_DIR) -L$(LDINC_DIR) \
	  -nostartfiles \
	  -nostdlib \
	  -Wl,--gc-sections \
	  -Wl,--no-warn-mismatch \
	  -Wl,--script=$(LDSCRIPT) \
	  -Wl,--build-id=none
	  # -Wl,--script=$(LDREGIONS) \

# Flags that help with debug. Note that --noinhibit-exec breaks make by
# producing a file hiding any errors. The map and symbol cross reference
# options clearly show how memory is being used.
LFLAGS += -Wl,-Map=$(PROJECT).map \
	  -Wl,-cref
# Other loader flags not currently used:
#  -fshort-enums is not used.  enums that appear in structs use pack attribute.
#         -Wl,--noinhibit-exec

# Source files used from the TinyUSB package, releative to TINYUSB/src
TINYUSB_SOURCE += \
	tusb.c \
	common/tusb_fifo.c \
	device/usbd.c \
	device/usbd_control.c \
	class/cdc/cdc_device.c \
	class/msc/msc_device.c \
	class/usbtmc/usbtmc_device.c \
	class/vendor/vendor_device.c \
	portable/$(VENDOR)/$(CHIP_FAMILY)/dcd_eptri.c

# C source
SRC_C += $(wildcard *.c) $(wildcard ../third_party/libbase/*.c)
SRC_C += $(addprefix $(TINYUSB)/src/, $(TINYUSB_SOURCE))

%.init: %.bin
	od -v -tx4 -w4 $< | awk '{if(NF>1){print $$2}}' > $@
%-debug.bin: %.elf
	$(OBJCOPY) --change-section-address .text=0 -S -O binary $< $@

# Verbose mode can be enabled by adding V=1 on the command line: "make V=1 all" 
QUIET := @
ifeq ("$(V)","1")
QUIET :=
$(info CFLAGS $(CFLAGS)) $(info )
$(info LFLAGS $(LFLAGS)) $(info )
$(info ASFLAGS $(ASFLAGS)) $(info )
endif

#OBJ += $(addprefix $(BUILD)/obj/, $(SRC_S:.S=.o))
OBJ += $(addprefix $(BUILD)/obj/, $(SRC_C:.c=.o))
OBJ_DIRS = $(sort $(dir $(OBJ)))
$(OBJ): | $(OBJ_DIRS)
$(OBJ_DIRS):
	$(QUIET)$(MKDIR) -p $@

# The only standard library functions used are the libc versions of
# memset and memcpy. These have been extracted and placed in libmemory
# ensuring no other functions are unexpectedly picked up from libc
# The libgcc library contains 64-bit math multiplication and division used
# by the CLI.
#LIBS += -lgcc -lm -lnosys -lc
LIBS += -L../lib -lmemory -lgcc

# Set all as default goal
.DEFAULT_GOAL := all
# All includes the main program and its helper programs
EXTRA = bios fbms
#EXTRA += $(addsuffix _$(PROJECT), $(EXTRA_ROOT))
ALL   = $(PROJECT) $(EXTRA)
.PHONY:	$(ALL)
all:	$(ALL)

CRT0 := $(BUILD)/obj/crt0.o $(BUILD)/obj/bios_crt0.o $(BUILD)/obj/fbms_crt0.o
fbms:	    ASFLAGS += -DSKIP_INIT

$(ALL): %: $(BUILD)/%.bin $(BUILD)/%.hex

$(BUILD)/$(PROJECT).elf: $(OBJ) $(BUILD)/obj/crt0.o
	@echo LINK $@
	$(QUIET)$(CC) -o $@ $(LFLAGS) $^ -Wl,--start-group $(LIBS) -Wl,--end-group

$(BUILD)/bios.elf: $(BUILD)/obj/bios_crt0.o $(OBJ)
	@echo LINK $@
	$(QUIET)$(CC) -o $@ $(LFLAGS) $^ -Wl,--start-group $(LIBS) -Wl,--end-group

$(BUILD)/fbms.elf: $(BUILD)/obj/fbms_crt0.o $(OBJ)
	@echo LINK $@
	$(QUIET)$(CC) -o $@ $(LFLAGS) $^ -Wl,--start-group $(LIBS) -Wl,--end-group

$(BUILD)/%.bin: $(BUILD)/%.elf
	@echo CREATE $@
	$(QUIET)$(OBJCOPY) -O binary $^ $@

$(BUILD)/%.hex: $(BUILD)/%.elf
	@echo CREATE $@
	$(QUIET)$(OBJCOPY) -O ihex $^ $@

# TinyUSB needs to find <csr.h> but LiteX needs to find <generated/csr.h>
$(BUILD)/obj/$(TINYUSB)/src/portable/$(VENDOR)/$(CHIP_FAMILY)/dcd_eptri.o: \
	CFLAGS += -I$(if $(RELEASE), \
		../../release/$(RELEASE)/include/generated/, \
		../../hw/build/software/include/generated/)

# Set vpath to point to the top of the tree so that the source files can be
# located. This scheme enables a single build rule to compile all .c files.
vpath %.c ..
$(BUILD)/obj/%.o: %.c
	@echo CC $(notdir $@)
	$(QUIET)$(CC) $(CFLAGS) -c -MD -o $@ $<
	@# The following fixes the dependency file.
	@# See http://make.paulandlesley.org/autodep.html for details.
	$(QUIET)$(CP) $(@:.o=.d) $(@:.o=.P); \
	  $(SED) -e 's/#.*//' -e 's/^.*:  *//' -e 's/ *\\$$//' \
	      -e '/^$$/ d' -e 's/$$/ :/' < $(@:.o=.d) >> $(@:.o=.P); \

# ASM sources with .S extenstion
vpath %.S . ..
$(BUILD)/obj/%.o: %.S
	@echo AS $(notdir $@)
	$(QUIET)$(CC) -x assembler-with-cpp $(ASFLAGS) -c -o $@ $<

# Three programs each need their own version of main() so crt0 is compiled with
# a different prefix for each program. Each individual program has
# <project>_main and <project>_isr while the true main belongs to the runtime
# which is assembled by the generic %.o:%.S rule above.
$(BUILD)/obj/%crt0.o: crt0.S
	@echo AS $(notdir $@)
	$(QUIET)$(CC) -x assembler-with-cpp $(ASFLAGS) -DCRT0_PREFIX=$(subst crt0.o,,$(notdir $@)) -c -o $@ $<

size: $(BUILD)/$(PROJECT).elf
	-@echo ''
	$(QUIET)$(SIZE) $<
	-@echo ''

INCLUDES = . $(INC) $(TINYUSB)/src $(TINYUSB)/src/common $(TINYUSB)/src/class/cdc $(TINYUSB)/hw/bsp
#$(shell perl -e 'foreach (@ARGV) { s/// and print "$$_/*.h " if /^-I/}' -- $(CFLAGS))
.PHONY: tags
tags:
	$(info INCLUDES $(INCLUDES)) $(info )
	ctags $(SRC_C) $(SRC_A) $(INCLUDES:=/*.h) 2>/dev/null

.PHONY: clean
clean:
	$(RM) -rf $(BUILD)

# Print out the value of a make variable.
# https://stackoverflow.com/questions/16467718/how-to-print-out-a-variable-in-makefile
print-%:
	@echo $* = $($*)

DEPFILES := $(OBJ:%.o=%.d)
$(DEPFILES):
include $(wildcard $(DEPFILES))
