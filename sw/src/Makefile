#
# Makefile - Part of a2fomu - Copyright (c) 2020-2021 Doug Eaton
#
# This file is part of a2fomu which is released under the two clause BSD
# licence.  See file LICENSE in the project root directory or visit the
# project at https://github.com/elecbrick/a2fomu for full license details.

# Build routine for all the software that runs in A2Fomu control processor.
# Multiple indpependent executables exist for the following purposes:
#   runtime

# Build environment
BUILD      := .obj
PACKAGE    := a2fomu

# Set all as default goal
.DEFAULT_GOAL := all
# All includes the main program and its helper programs
PROJECT := runtime
EXTRA   := bios fbms
ALL     := $(PROJECT) $(EXTRA)
all:	   $(ALL) size
.PHONY:	   $(ALL)
RUNTIME  = $(BUILD)/$(PROJECT).elf
FBMS     = $(BUILD)/fbms.elf
BIOS     = $(BUILD)/bios.elf

# Software can be built for a specific hardware configuration. The releases
# directory in the project root contains a sub-folder for each official version
# and may contain unofficial versions as well. The include directory of the
# particular version should contain the generated output as well as the litex
# version specific hardware folder.
ifdef RELEASE
RELEASES   := $(subst ../../release/,,$(wildcard ../../release/*))
ifeq ($(filter $(RELEASE), $(RELEASES)),)
    $(error Invalid release specified)
endif
endif

# Compiler flags used for both compilation and linking
CFLAGS += \
  -march=rv32i \
  -mabi=ilp32 \
  -nostdlib \
  -DCFG_TUSB_MCU=OPT_MCU_VALENTYUSB_EPTRI \
  -D__vexriscv__ \
  -fno-common \
  -fomit-frame-pointer \
  -std=gnu11 \
  -flto \
  -fno-inline \
  -ggdb3 \
  -DDEBUG=0

SRC_S   := crt0-rgbraw.o
ASFLAGS += $(CFLAGS)

# Cross Compiler for RISC-V
CROSS_COMPILE ?= riscv64-unknown-elf-
CC = $(CROSS_COMPILE)gcc
CXX = $(CROSS_COMPILE)g++
OBJCOPY = $(CROSS_COMPILE)objcopy
SIZE = $(CROSS_COMPILE)size
MKDIR = mkdir
SED = sed
CP = cp
RM = rm

#-------------- Source files and compiler flags --------------

# Compiler Flags
# The following is needed if dirent_fat has filename[8],ext[3] rather than [11]
# https://gcc.gnu.org/bugs/#known: Loops do not terminate
#	-fno-aggressive-loop-optimizations
	# TODO
CFLAGS += \
	-fdata-sections \
	-ffunction-sections \
	-fsingle-precision-constant \
	-fno-strict-aliasing \
	-Wdouble-promotion \
	-Wstrict-prototypes \
	-Wall \
	-Werror \
	-Wextra \
	-Wfatal-errors \
	-Werror-implicit-function-declaration \
	-Wfloat-equal \
	-Wundef \
	-Wshadow \
	-Wwrite-strings \
	-Wsign-compare \
	-Wmissing-format-attribute \
	-Wunreachable-code \
	-Wcast-align

# Debugging/Optimization
ifeq ($(DEBUG), 1)
  CFLAGS += -Og -ggdb
else
  CFLAGS += -Os
endif
ifeq ($(LIST), 1)
  CFLAGS += -Wa,-alh,-L
endif

# Simulating the runtime with Verilator or iverilog is sped up by loading the
# executable directly into the very large ROM that is also simulated. This
# means the executable loads into address 0 when simulating.
# When not simulating, assume a boot-loader in ROM is copying the image from
# Flash into RAM using only local variables. It is not safe to let Foboot load
# this image directly as its interrupt handler updates global variables and
# will corrupt the image.
ifeq ($(SIM), 1)
$(info Simulation build)
CFLAGS     += -DSIMULATION
LDREGION   := sim.ld
endif

# TinyUSB: The macros TOP, VENDOR and CHIP_FAMILY must be defined when
# compiling TinyUSB source files.
TINYUSB    := ../tinyusb
TOP         = $(TINYUSB)
VENDOR      = valentyusb
CHIP_FAMILY = eptri

INC         := ../include
LDINC_DIR   := ../../hw/build/software/include/generated/

# Use the header files generated by a particular version of the gateware.
# Eg: "$ make RELEASE=1.0"
ifdef RELEASE
RELEASE_DIR := ../../release/$(RELEASE)/
INC	    := $(RELEASE_DIR)/include/ ../include
LDINC_DIR   := $(RELEASE_DIR)/include/generated/
endif

INC         += ../../hw/build/software/include/
INC         += ../../hw/deps/litex/litex/soc/software/include/
INC         += ../../hw/deps/litex/litex/soc/cores/cpu/vexriscv
INC         += $(TINYUSB)/src $(TINYUSB)/hw
INC         += $(TINYUSB)/src/portable/$(VENDOR)/$(CHIP_FAMILY)

CFLAGS += $(addprefix -I,$(INC))

# LiteX produces two linker scripts that are included by the main script.
# The files regions.ld and output.ld are in the include/generated/ directory
# from either the build or the release directory. The make variable LDINC_DIR
# points to that location and is passed to ld via the -L option.
LD_DIR     := ../lib
LDSCRIPT   := linker.ld

# Determine location of executable. BIOS is in ROM, FBMS resides in Flash and
# the main runtime is in RAM. The region is specific to a linker script and
# cannot be parameterized, Thereforn a unique scripts is required to target
# each region.

$(RUNTIME): LOAD_RAM_ADDR := 0x10000000
$(RUNTIME): LDREGION      := ram.ld
$(BIOS):    LDREGION      := rom.ld
$(FBMS):    LDREGION      := flash.ld
$(FBMS):    LOAD_RAM_ADDR := 0x2001a000

$(FBMS): CFLAGS     += -DLOAD_RAM_ADDR=$(LOAD_RAM_ADDR)
$(FBMS): ADD_LFLAGS  = -Wl,-Ttext=$(LOAD_RAM_ADDR)

LDSCRIPTS   = $(LDREGION) $(LDSCRIPT)
LDPREFIX   := -Wl,--script=

ifdef LOAD_BOOT_CONFIG
CFLAGS     += -DLOAD_BOOT_CONFIG=$(LOAD_BOOT_CONFIG)
endif

LFLAGS  = $(CFLAGS) $(ADD_LFLAGS) -L$(LD_DIR) -L$(LDINC_DIR) \
	  -nostartfiles \
	  -nostdlib \
	  -Wl,--gc-sections \
	  -Wl,--no-warn-mismatch \
	  $(addprefix $(LDPREFIX), $(LDSCRIPTS)) \
	  -Wl,--build-id=none \

$(warning s1 $(LDSCRIPTS))
$(warning s2 $(addprefix $(LDPREFIX), $(LDSCRIPTS)))

# Flags that help with debug. Note that --noinhibit-exec breaks make by
# producing a file hiding any errors. The map and symbol cross reference
# options clearly show how memory is being used.
LFLAGS += -Wl,-Map=$@.map \
	  -Wl,-cref
# Other loader flags not currently used:
#  -fshort-enums is not used.  enums that appear in structs use pack attribute.
#         -Wl,--noinhibit-exec

# Source files used from the TinyUSB package, releative to TINYUSB/src
TINYUSB_SOURCE = \
	tusb.c \
	common/tusb_fifo.c \
	device/usbd.c \
	device/usbd_control.c \
	class/cdc/cdc_device.c \
	class/msc/msc_device.c \
	class/usbtmc/usbtmc_device.c \
	class/vendor/vendor_device.c \
	portable/$(VENDOR)/$(CHIP_FAMILY)/dcd_eptri.c

# C source
SRC_C += $(wildcard *.c) $(addprefix $(TINYUSB)/src/, $(TINYUSB_SOURCE))

%.init: %.bin
	od -v -tx4 -w4 $< | awk '{if(NF>1){print $$2}}' > $@
%-debug.bin: %.elf
	$(OBJCOPY) --change-section-address .text=0 -S -O binary $< $@

# Verbose mode can be enabled by adding V=1 on the command line: "make V=1 all" 
QUIET := @
ifeq ("$(V)","1")
QUIET :=
#$(info CFLAGS $(CFLAGS)) $(info )
#$(info LFLAGS $(LFLAGS)) $(info )
#$(info ASFLAGS $(ASFLAGS)) $(info )
endif

#OBJ += $(addprefix $(BUILD)/obj/, $(SRC_S:.S=.o))
OBJ += $(addprefix $(BUILD)/obj/, $(SRC_C:.c=.o))
OBJ_DIRS = $(sort $(dir $(OBJ)))
$(OBJ): | $(OBJ_DIRS)
$(OBJ_DIRS):
	$(QUIET)$(MKDIR) -p $@

# The only standard library functions used are the libc versions of
# memset and memcpy. These have been extracted and placed in libmemory
# ensuring no other functions are unexpectedly picked up from libc
# The libgcc library contains 64-bit math multiplication and division used
# by the CLI.
#LIBS += -lgcc -lm -lnosys -lc
LIBS += -L../lib -lmemory -lgcc

CRT0 := $(BUILD)/obj/crt0.o $(BUILD)/obj/bios_crt0.o $(BUILD)/obj/fbms_crt0.o
fbms:	    ASFLAGS += -DSKIP_INIT

$(ALL): %: $(BUILD)/%.bin # $(BUILD)/%.hex

$(RUNTIME): $(OBJ) $(BUILD)/obj/crt0.o
	@echo LINK $@
	$(QUIET)$(CC) -o $@ $(LFLAGS) $^ -Wl,--start-group $(LIBS) -Wl,--end-group

$(BIOS): $(BUILD)/obj/bios_crt0.o $(OBJ)
	@echo LINK $@
	$(QUIET)$(CC) -o $@ $(LFLAGS) $^ -Wl,--start-group $(LIBS) -Wl,--end-group

$(FBMS): $(BUILD)/obj/fbms_crt0.o $(OBJ)
	@echo LINK $@
	$(QUIET)$(CC) -o $@ $(LFLAGS) $^ -Wl,--start-group $(LIBS) -Wl,--end-group

$(BUILD)/%.bin: $(BUILD)/%.elf
	@echo CREATE $@
	$(QUIET)$(OBJCOPY) -O binary $^ $@

$(BUILD)/%.hex: $(BUILD)/%.elf
	@echo CREATE $@
	$(QUIET)$(OBJCOPY) -O ihex $^ $@

# TinyUSB needs to find <csr.h> but LiteX needs to find <generated/csr.h>
$(BUILD)/obj/$(TINYUSB)/src/portable/$(VENDOR)/$(CHIP_FAMILY)/dcd_eptri.o: \
	CFLAGS += -I$(if $(RELEASE), \
		../../release/$(RELEASE)/include/generated/, \
		../../hw/build/software/include/generated/)

# Set vpath to point to the top of the tree so that the source files can be
# located. This scheme enables a single build rule to compile all .c files.
vpath %.c ..
$(BUILD)/obj/%.o: %.c
	@echo CC $(notdir $@)
	$(QUIET)$(CC) $(CFLAGS) -c -MD -o $@ $<
	@# The following fixes the dependency file.
	@# See http://make.paulandlesley.org/autodep.html for details.
	$(QUIET)$(CP) $(@:.o=.d) $(@:.o=.P); \
	  $(SED) -e 's/#.*//' -e 's/^.*:  *//' -e 's/ *\\$$//' \
	      -e '/^$$/ d' -e 's/$$/ :/' < $(@:.o=.d) >> $(@:.o=.P); \

# ASM sources with .S extenstion
vpath %.S . ..
$(BUILD)/obj/%.o: %.S
	@echo AS $(notdir $@)
	$(QUIET)$(CC) -x assembler-with-cpp $(ASFLAGS) -c -o $@ $<

# Three programs each need their own version of main() so crt0 is compiled with
# a different prefix for each program. Each individual program has
# <project>_main and <project>_isr while the true main belongs to the runtime
# which is assembled by the generic %.o:%.S rule above.
$(BUILD)/obj/%crt0.o: crt0.S
	@echo AS $(notdir $@)
	$(QUIET)$(CC) -x assembler-with-cpp $(ASFLAGS) -DCRT0_PREFIX=$(subst crt0.o,,$(notdir $@)) -c -o $@ $<

.PHONY: size
size: 	$(addprefix $(BUILD)/,$(addsuffix .elf,$(ALL)))
	-@echo ''
	$(QUIET)$(SIZE) $^
	-@echo ''

INCLUDES = . $(INC) $(TINYUSB)/src $(TINYUSB)/src/common $(TINYUSB)/src/class/cdc $(TINYUSB)/hw/bsp
#$(shell perl -e 'foreach (@ARGV) { s/// and print "$$_/*.h " if /^-I/}' -- $(CFLAGS))
.PHONY: tags
tags:
	$(info INCLUDES $(INCLUDES)) $(info )
	ctags $(SRC_C) $(SRC_A) $(INCLUDES:=/*.h) 2>/dev/null

.PHONY: clean
clean:
	$(RM) -rf $(BUILD)

# Print out the value of a make variable.
# https://stackoverflow.com/questions/16467718/how-to-print-out-a-variable-in-makefile
print-%:
	@echo $* = $($*)

DEPFILES := $(OBJ:%.o=%.d)
$(DEPFILES):
include $(wildcard $(DEPFILES))
